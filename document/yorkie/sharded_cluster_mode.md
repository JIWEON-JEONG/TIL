# Sharded Cluster Mode 정리 

## 배경

기존의 Broadcast Cluster Mode 의 다음과 같은 한계점을 극복하기 위해 이를 제안하게 되었다. 

- 높은 동기화 오버헤드 : 여러 서버가 데이터의 일관성을 유지하기 위해, 서버 간 동키화 메커니즘이 필수적이다. 이 과정에서 발생하는 통신 및 동기화 비용이 매우 큼.
- 확장성 및 효율성 : 서버가 많아질수록 동기화에 필요한 비용은 기하급수적으로 증가. 서버를 추가해도 성능이 선형적으로 증가하지 않을 수 있음. 즉 대규모 워크로드를 처리하는데 구조적인 한계 존재.

### 서버 간 동기화 메커니즘 - Broadcast (Legacy)

실시간 협업 툴 같은 경우, 서버가 클라이언트와 실시간으로 통신하며, 데이터 변경 사항을 즉시 반영해야한다. 
그렇기 때문에, "실시간으로 변경되는 이벤트를 모든 연결된 클라이언트에게 Push 하는 역할" 이 필수적으로 필요하다.

예를들어, 사용자 A 와 B가 동일한 문서를 보고 있을때, A가 문서를 수정할경우 B 는 이 변경사항을 실시간으로 인지해야한다. 
데이터베이스를 주기적으로 Polling 하거나, 별도의 알림이벤트를 통해 처리 할 수 있다. 

하지만 매번 클라이언트의 요청이 있을때마다 DB 에 접근하여 데이터를 읽고 쓰는것은 매우 비효율적이다. 이를 해결하기 위해 
서버는 in-memory 에 캐시하여 이를 해결한다. 

따라서 모든 서버가 문서의 현재 상태를 메모리에 똑같이 가지고 있어야한다. 이를 위해 서버간 변경사항을 Broadcast 하는 것이다.

### 서버 간 동기화 메커니즘 - Sharded Cluster Mode 

대규모 워크로드를 효율적으로 처리하고, 높은 가용성, 신뢰성, 확장성을 보장하기위해 제안되었다.
핵심은 각 서버에 특정 워크로드를 할당하고, 조회시스템을 통해 동일한 워크로드가 항상 같은 서버로 라우팅되도록 한다. 

1. 문서를 워크로드의 최소단위로 사용 : 특정 문서의 상태와 데이터를 담당 서버에게 할당하면서 서버간 공유 및 동기화 제거.
2. 샤딩 전략 : Consistent Hashing 사용하여 요청을 효율적으로 분산.
3. 조회 전략 : Server Side Discovery 사용하여 요청을 담당 서버로 라우팅.

## 동작 과정

1. 클라이언트의 접속 및 요청 전송 (클라이언트 -> 라우터)
   - 클라이언트(사용자)는 '문서-01'을 편집하기 위해 Yorkie 서버에 접속합니다.
   - 클라이언트의 요청은 Istio Ingress Gateway(Envoy)로 전달됩니다.
   - 이때, 클라이언트는 HTTP 요청 헤더에 샤딩 키(x-shard-key: 문서-01)를 포함하여 보냅니다. 이 키는 Consistent Hashing을 위한 식별자 역할을 합니다.  


2. 요청 라우팅 (라우터 -> Yorkie 서버)
   - Istio Ingress Gateway는 DestinationRule 설정에 따라 x-shard-key 값을 기반으로 Consistent Hashing을 수행한다.

   - 해시 값 계산 결과, '문서-01'의 **책임 서버(owner)**가 **서버 B**임을 확인한다.

   - Gateway는 클라이언트의 요청을 서버 B로 라우팅한다. Consistent Hashing 덕분에 '문서-01'에 대한 모든 요청은 항상 서버 B로만 전달된다.  

3. 서버의 워크로드 처리 (Yorkie 서버)
   - **서버 B**는 요청을 받으면, 자신이 '문서-01'의 책임 서버이므로 문서를 처리한다.

   - 메모리 상태 로드/업데이트:
     - 만약 '문서-01'이 서버 B의 메모리에 아직 로드되지 않았다면, 데이터베이스에서 문서를 읽어와 메모리에 로드한다.
     - 클라이언트의 변경 요청을 메모리 내 '문서-01' 상태에 즉시 적용한다.  

   - 실시간 변경 전파:
     - 서버 B는 WatchDocument를 통해 '문서-01'에 **연결(attach)**된 모든 클라이언트에게 변경 사항을 gRPC 서버 스트리밍을 통해 실시간으로 전달한다.
     - 이 과정은 **이벤트 전파(Event Propagation)**의 실제 구현체이다. 다른 서버(A, C)에 연결된 클라이언트들은 서버 B와 무관하므로 이벤트 전파 대상이 아니다.



4. 데이터베이스 업데이트 (Yorkie 서버 -> DB)
   - 서버 B는 메모리 내의 상태를 변경한 후, 이 변경 사항을 데이터베이스에 반영합니다.

   - 데이터베이스는 '문서-01'의 최신 상태를 영구적으로 저장합니다.

   - 이때, 서버 B만 DB에 접근하여 '문서-01'을 업데이트합니다. 다른 서버(A, C)는 이 과정에 관여하지 않습니다.
   


5. 다른 클라이언트의 관찰 (클라이언트 -> 라우터 -> Yorkie 서버)
   - 문서-01'을 관찰(watch)하는 다른 클라이언트(예: 사용자 2)의 요청 역시 동일한 라우팅 과정을 거쳐 서버 B로 연결된다.

   - 서버 B는 이 클라이언트와 장기 연결(gRPC 스트리밍)을 맺고, 향후 발생하는 모든 '문서-01'의 변경 사항을 실시간으로 푸시한다.  


## 시스템 구성 
- Yorkies: 클라이언트 요청을 받아 해시 키와 일관성 해싱 알고리즘에 따라 서버로 라우팅하는 라우터(프록시) 역할

- Yorkie Service Registry: Yorkie 서버들의 메타데이터와 설정 정보를 저장하는 서비스 레지스트리

- Yorkie Service(s): 실제 워크로드를 처리하는 서버들

## 해결해야 할 문제점과 해결 방안




