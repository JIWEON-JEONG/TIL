## Checkpoint 

### 배경 
LostUpdate 문제를 해결하기 위해 고안되었다. 

### 문제 예시 
철수와 영희가 **문서 A**를 함께 편집하고 있다고 가정한다.

~~~
안녕하세요.

반갑습니다.

잘 부탁드립니다.
~~~

철수가 3번 줄을 "잘 지내봅시다."로 변경했을때,

철수는 서버에 "3번 줄을 '잘 지내봅시다.'로 바꾸어주세요." 라는 명령을 보낸다.

서버는 이 명령을 받아서 문서의 3번 줄을 변경한다.

영희는 철수가 변경하기 전의 문서를 보고 있습니다. (버전 0)

영희가 1번 줄을 "안녕!"으로 변경하고 저장합니다.

영희의 클라이언트는 서버에 "1번 줄을 '안녕!'으로 바꾸어주세요." 라는 명령을 보냅니다.

하지만 이 명령이 서버에 도착하기 직전에, 철수가 3번 줄을 수정한 명령이 이미 서버에 도착하고 처리되었습니다. (서버 버전은 1)

이제 서버의 문서에는 3번 줄이 이미 "잘 지내봅시다."로 변경된 상태입니다.

이렇게 될 경우 철수의 명령은 Overwrite 되어 유실 될 수 있다.

### 해결 예시

> Checkpoint는 클라이언트가 어떤 버전(버전 번호 = 시퀀스)의 문서를 기반으로 작업했는지 서버에 알려주는 역할을 한다.

영희가 "1번 줄을 '안녕!'으로 바꾸어주세요."라는 명령을 보낼 때, Checkpoint (server_seq: 0, client_seq: 0)도 함께 보내게된다.

서버는 이 요청을 받자마자, "어? 영희는 버전 0을 보고 있네. 하지만 서버의 현재 버전은 1이야. 영희는 버전 1에서 일어난 철수의 변경 내용을 모르는구나!"라고 
즉시 판단할 수 있게 된다.

영희에게 "네가 보낸 명령은 이전 버전이야. 일단 서버의 최신 변경 사항(철수의 수정 내용)을 먼저 가져가서 너의 문서에 적용해. 그리고 나서 다시 변경 사항을 보내줘." 라고 알려줍니다.

영희는 철수의 변경 사항을 받아 자신의 문서에 합친 후, 자신의 변경 사항을 서버의 최신 버전을 기반으로 다시 보내게 됩니다.

즉, Checkpoint는 서버가 클라이언트의 상태를 정확히 파악하여, 오래된 정보를 기반으로 한 변경 사항이 최신 내용을 덮어쓰는 것을 막아주는 중요한 장치입니다. 이것이 바로 시퀀스(버전 번호)를 사용하는 이유입니다.

