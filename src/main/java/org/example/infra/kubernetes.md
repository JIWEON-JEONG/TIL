### VM and Container 

하나의 물리적 컴퓨터 리소스를 여러개의 독립적인 가상환경으로 나누어 효율적으로 활용하기 위한 기술.
VM 은 OS 가 환경마다 존재하기 때문에, 부팅속도가 느리고 환경 간 불일치가 발생하는 단점이 있다. 

이를 해결하기 위해, 하나의 호스트 운영체제로 통합하고 그위에 컨테이너 엔진을 설치하여 해결하는 방식이 고안되었다.

가상머신은 하나의 서버에서 여러 운영체제의 리소스와 기능이 필요한 애플리케이션을 실행하는데에 좋은 선택이 될 수는 있지만,
이러한 이유가 아니라면 더 가볍고, 이식성 및 확장성이 뛰어난 컨테이너 기술이 더 좋은 방안이 될 수 있다.

컨테이너 또한 VM 의 기술을 아예 사용하지 않는 것은 아니다. 
A 라는 도커 이미지로 패키징 된 어플리케이션이 존재할때, 서로 다른 운영체제에서 실행 할 경우 환경간의 차이로 인해 문제가 발생 할 수 있다.

이를 해결하기 위해, Docker 에서는 Desktop 소프트웨어를 통해 경량의 Linux VM 을 실행하여 일관된 OS 위에서 실행 할 수 있도록 도와준다.

### Kubernetes

Container 기술을 통해, 애플리케이션을 패키징 하고 실행하는 방식은 혁신되었다. 
하지만 컨테이너를 운영시 이러한 문제점들이 존재하였다.

- 배포자동화 : 수십, 수백개의 컨테이너를 관리 및 배포 시 비효율
- 스케일링 : 수동 스케일링은 신속한 대응을 어렵게 만듬
- 자가복구 
- 서비스 디스커버리 : 컨테이너 들간의 IP 가 수시로 바뀌기 때문에 어떻게 통신할 것인지에 대한 해법 부재.
- 무중단 업데이트 : 서비스 중단 없이 순차적으로 배포하는 작업을 수동으로 해야 했음.

이러한 문제들을 쿠버네티스가 자동화된 방식으로 해결.

### Pod

쿠버네티스의 기본적인 배포단위. Pod 안에 컨테이너를 넣어서 배포한다. 
여러개의 컨테이너를 넣어 배포 할 수 있다.

한 Pod 내의 컨테이너들을 네트워크와 스토리지를 공유한다. (같은 IP 주소 == 같은 네임스페이스)

하나의 Pod = 하나의 애플리케이션 인스턴스 라는 개념이 쿠버네티스 스케일링의 핵심.
이유는 
- 장애 복구의 비효율성: 하나의 컨테이너가 다운 될 경우, 다른 컨테이너까지 모두 중단된다.


#### Main Container and Sidecar Container
관심사의 분리를 위해 MainContainer 와 SideContainer 로 분류된다.
주로 애플리케이션 개발자가 자신의 서비스 로직이 담긴 애플리케이션이 MainContainer 에 배포되고, 
플랫폼 팀이나 인프라팀에서 공통 시스템 (로깅, 모니터링 등)을 SideCar 형식으로 Pod 에 붙히게 된다. 이를 통해 
관심사가 분리되고 효율적으로 운영할 수 있다.

#### Envoy and Istio
Microservice 가 확산되면서 수많은 서비스간의 통신이 복잡해졌다. 비즈니스로직 외에 네트워크 문제에 많은 시간을 할애하게 되면서 이를 해결하기 위해
Envoy (L7 프록시) 가 나오게 되었다.

마이크로서비스 옆에 Sidecar 로 배포되는 프록시로 서비스 간 모든 네트워크 트래픽을 가로채고 제어한다. 

Envoy 와 같은 프록시를 각 서비스에 일일이 수동으로 배포하고 관리하는 것은 매우 비효율적이였다. 
Istio 는 이러한 문제를 해결하기 위한 Service Mesh 플랫폼이다. Envoy 를 Istio 를 통해 자동으로 관리하고 설정 할 수 있다.

Envoy는 마이크로서비스 통신의 실제 기능을 수행하고, Istio는 그 기능을 손쉽게 관리하고 제어하기 위한 플랫폼.

### Deployment
Pod 를 관리하는 상위 레벨의 컨트롤러.

자가 복구 및 무중단 배포를 선언형으로 상태 명시를 통해 구현할 수 있다.

### Service

Pod 에 안정적인 네트워크 연결을 제공하는 추상화 계층.
Pod 는 언제든지 죽고, 새로운 IP 주소를 할당 받을 수 있기 때문에 이러한 문제를 Service 가 해결해준다.

#### Service 에서 Pod 로의 요청 흐름

1. 네트워크 규칙 생성 : 각 워커노드에는 kube-proxy 라는 에이전트가 실행. 각 Pod 들을 지속적으로 감시하며 Pod 생성 및 제거 시 노드에 존재하는 iptables 자동 업데이트.
2. 트래픽 가로채기 : 외부에서 Service IP 로 요청이 들어올 경우 iptables 가 트래픽 가로챔.
3. 로드 밸런싱 및 포워딩: iptables 규칙은 해당 Service에 연결된 파드들의 IP 주소 목록(Endpoints)을 통해 파드 중 하나를 무작위로 선택하거나(라운드 로빈 등) 미리 정해진 정책에 따라 포워딩.
4. 패킷 변환: 선택된 파드의 IP 주소와 포트로 패킷의 목적지를 변경(NAT, Network Address Translation)한 후, 해당 파드로 최종 요청을 전달합니다.