- 객체지향의 사실과 오해
"객체지향의 기본사상은 상태와 상태를 조작하기 위한 행동을 하나의 단위로 묶는것."
"객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로서 객체의 자율성을 유지한다."
- 객체가 다른 객체와 협력 하는 유일한 방법은 다른 객체에게 메시지(요청) 을 보내는 것이다.

저는 접근 권한을 구분하는 것이 매우 도움이 된다고 봅니다. 보통 private/protected
멤버는 구현에 관련된 것들이죠. 잘 설계된 클래스는 public 인터페이스만을 통하여
클라이언트가 원하는 기능을 제공하고 디테일한 구현은 감춤으로써 코드를 유연하게
만들 수 있습니다.


private -
protected -
default -
public -

-캡슐화와 정보은닉

- 캡슐화 : 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 외부로 노출 하는 것은 행동 뿐이며 , 
- 외부에서 객체에 접근 할 수 있는 유일한 방법 역시 행동 뿐이다. 예외 static
- ex)카세트테이프 같은 기계

-캡슐화 를 통해 얻는 이점
-> 상태를 잘 정의된 행동 집합 뒤로 캡슐화 하는 것은 객체의 자율성을 높인다. (객체가 제공하는 행동만을 요청 하기 때문에)
-> 자율성이 높다는 것은 객체간의 협력을 단순하고 유연하게 만든다. 이것이 상태를 캡슐화 하는 이유다.

캡슐화(영어: encapsulation)는 객체 지향 프로그래밍에서 다음 2가지 측면이 있다:[1][2]

객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고,[3][4]
실제 구현 내용 일부를 내부에 감추어 은닉한다.[5][6]
속성인 데이터와 메서드의 결합은 C++의 경우 멤버함수를 호출할 때 객체의 저장공간을 멤버함수에 넘겨 데이터 처리를 하도록 하는 방법을 사용한다.

내부에 감추는 방법으로는 언어적 측면에서 접근지정자를 두어 은닉의 정도를 기술하여 구현한다.
은닉의 정도를 접근지정자로 기술하고 해당 영역에 들어가는 속성이나 메서드를 제한하면 된다.
접근지정자에 의해 제한된 멤버들은 컴파일러에 의해 판단된다.
언어적 측면에서 접근지정자에 의해 정의된 해당 멤버변수나 멤버함수는 코드 중에 접근방식을 위반한 코드를 작성하면 컴파일 오류로 처리하고 실행코드 생성을 제한한다.

캡슐화의 가장큰 장점은 정보은닉(Information Hiding)에 있습니다.
외부에서 객체접근하는데 있어서 정보를 숨기고 객체의 연산을 통해서만 접근이 가능하게 하는 것입니다.
정보은닉의 장점은 외부에서 특정 객체의 데이터 및 함수를 직접 접근을 막음으로써 변경을 못하게 하고 유지보수나 확장시 오류의 범위를 최소화 할 수 있고,
객체내 정보손상, 오용을 방지하고, 조작법이 바뀌어도 사용방법 자체는 바뀌지 않고, 데이터가 변경되어도 다른 객체에 영향을 주지 않기 때문에 독립성이 좋고,
처리된 결과사용으로 이식성이 좋고, 객체를 모듈화 할 수있어 새로운 시스템의 구성에 하나의 모듈처럼 사용이 가능하다.

-자율성
객체가 할당된 책임을 수행하는 방법은 자율적으로 선택할 수 있다.
"객체의 자율성은 객체의 내부와 외부를 명확하게 구분 하는 것으로 부터 나온다"
"객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야 하며, 객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통 해야한다"
-객체지향사실과 오해 33pg

캐셔 와 바리스타의 예. 캐셔가 커피에 설탕을 타는 행위 .


