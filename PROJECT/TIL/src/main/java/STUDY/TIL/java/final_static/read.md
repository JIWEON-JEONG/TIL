@제어자 

접근 제어자 : public, protected, (default), privatee
그외 : final , static , syncronized 등등 ..

static
- 클래스의 공통적인

멤버변수 
- 모든 인스턴스에 공통적으로 사용되는 변수가 된다. 
- 인스턴스를 생성하지 않고도 사용 가능하다.
- 클래스가 메모리에 로드 될 때 생성된다.

메서드 
- 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
- static 메서드 내에서는 인스턴스 멤버들을 직접 사용 할 수 없다. 
- static 변수 또는 메서드 내 변수들만 사용가능

final

클래스 
- 변경될 수 없는 클래스 
- final class 는 상속 계층도에서 맨 마지막 . 자식을 가질 수 없는 클래스
- ex) String(보안 문제 - 비밀번호 , 자식이 접근 할 수 없도록), Math

메서드 
- 변경 될 수 없는 메서드 
- 즉 오버라이딩을 통해 재정의 될 수 없다.

멤버 변수, 지역변수
- 값을 변경할 수 없는 상수가 된다.

번외 
private static 메서드가 필요한 이유 

protected, default 이런 접근제어자는 언제 사용할까? -> 같이 알아볼것 !

객체 지향이란 
-> 클래스가 아니라 , 여러 객체들이 메시지를 통해 상호작용 , 협력 을 하는 공동체를 만드는것. 

<객체지향 사실과 오해>

- 상태 중심 설계가 아닌 행동중심 설계를 하라. 
- 예시를 한번 만들어볼까요? 같이? 65pg.
- 책임주도설계.(행동이 상태를 결정한다)

- 진정한 의미에서의 추상화 : 불필요한 부분을 도려내가면서 , 사물의 본질을 드러나게 하는 과정. -> 뚜렷한 목적이 있어야한다. 설계할때 생각을 해봐야 할 듯.
- 우리가 구현하고자 하는 애플리케이션의 목적이 무엇인지를 가장 먼저 파악하는것이 중요할거같다.

추상화를 하는 방법 
- 공통점을 취하고 차이점은 버리는 일반화를 통해 단순하게 구현
- 중요한 부분을 강조하기 위해 불필요한 부분을 제거함으로서 단순하게 만

- 즉 현실에 복잡성을 극복하는 것이다. 

데이터 타입 
- 메모리 안에 저장된 데이터의 종률르 분류하는데 사용하는 메모리 집합에 관한 메타 데이터.
- 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는 지를 결정한다.

타입을 결정지는 것은 행동이다!
서로 다른 데이터를 가지고 있는 객체라도 동일 하게 행동한다면 같은 타입의 객체이다.

반대로 서로 같은 데이터를 가지고 있다고 하더라도 , 다른 행동을 하고 있다면 그 객체들은 다른 타입으로 분류 해야한다. 

이것좀 어렵군..

행동이란 동일한 책임을 의미한다 즉 동일한 메시지 수신을 의미한다. -> 

내부 표현은 다를 수 있다. (다형성 과 연결) 
동일한 요청에 서로 다른 응답.

내부표현방식과 무관하게 행동만이 고려대상이라는 사실은 -> 외부에 내부 데이터를 숨겨야한다.
바로 이것이 캡슐화이다. 외부에 행동만을 제공하고 데이터는 행동뒤로 감쳐야한다. =>>>>>>>>>>> 94pg 이해해야할듯.

즉 행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야하는 데이터가 아니라 외부에 제공해야 하는 행동을 먼저 생각해야한다.

결국 타입의 목적은 : 동적으로 변하는 객체의 복잡성을 본질이 같은 객체가 상태가 변할 수 있구나 동적으로 바귈 수 있구나 라고 편하게 생각할 수 있게 해준다.
ex) 앨리스의 키가 변해도 어짜피 앨리스이다.

- 이러한 관점에서 타입은 추상화이다.

객체 다이어그램 ?? 정적 vs 동적 -> UML 다시 리마인드






