# 내가 보기위해 정리한 스프링 핵심 2

## DI 의존관계 주입
> 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고,
> 
> 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것.
> 
> 이를 통해 클라이언트 코드를 변경 하지 않고도 클라이언트가 호출 하는 대상의 타입 인스턴스 변경 가능하다.

## 추상화에 관하여
모든것을 인터페이스로 만드는것은 바람직하지 않다. 
> 추상화 라는 비용이 발생하기 때문에.

**실제 우리가 설계를 할때에는 확장 가능성이 없어보이는 클래스들은 구체클래스로 사용하고, 향후 필요할때 리팩토링을 통해서 인터페이스 도입 하는식으로 개발.**

## ApplicationContext & BeanFactory
- 스프링 컨테이너 는 @Configuration 이 붙은 클래스를 구성 정보로 인식한다. 
- 해당 클래스에서 @Bean 이 부은 메서드를 모두 호출 해서 반환된 객체를 스프링컨테이너에 등록한다. > 스프링 빈
- Bean 은 메서드 명을 스프링 빈의 이름으로 사용.

## Spring Bean 조회시 주의 할 점.
- 부모타입으로 조회시 자식이 둘 이상 있으면 중복오류 발생. 
> 빈 이름을 지정 하여 조회 하면서 해결. 
> 
## BeanDefinition
> 스프링 빈 설정 메타정보.
> 
> 다양한 형태의 메타정보를 추상화. -> XML , JAVA 등의 여러가지 형태로 지원 가능.

>스프링이 자바코드 또는 XML 같은 설정정보를 읽어서 BeanDefinition 구현체로 만든다.
> 
> 스프링컨테이너는 만들어진 BeanDefinition 을 기반으로 스프링 빈 생성.

## 싱글톤 컨테이너
스프링 컨테이너는 기본적으로 스프링빈을 싱글톤으로 관리한다. <br>
수많은 요청마다 매번 객체를 만들순 없으니, 싱글톤 패턴에 장점을 사용하면서 <br>
싱글톤 패턴이 가지는 단점들 <br>
1. 싱글톤 패턴을 위한 지저분한 코드 (ex) getInstance 같은 ..)
2. DIP , OCP 위반 등 

문제점을 해결할 수 있다. 

> 싱클톤 패턴을 통해 이미 만들어진 객체를 공유하여 효율적으로 사용 가능.

## 주의점 (중요!!!) - 빈을 생성할때 항상 생각해야 할 것.
싱글톤으로 사용 할 경우, 해당 빈을 무상태로 설계 해야한다. 
>그렇지 않으면 정말 큰 장애가 발생 할 수 있다. 
> 
> 예를 들어, 로그인을 했는데 다른사람 이름이 보여진다거나, 돈에 관련된 것은 .. 끔찍..

내가 사용하는 빈이 싱글톤 방식으로 사용된다면 
1. 특정 클라이언트에 의존적인 필드가 있는지 , 
2. 특정 클라이언트가 값을 변경할 수 있는 필드가 있는지, 
3. 필드 대신 자바에서 공유되지 않는 지역변수나 파라미터 , TreadLocal, 리턴을 하는 방법 등을 사용 해야 한다.

## @Configuration

> 스프링 빈이 싱글톤을 유지하도록 처리.

- isSameAs : 메모리상 같은 객체를 가리키는지 비교 (주소 비교)
- isEqualTo : 객체가 같은 값을 가지고 있는지 비교한다.


>만약 MemberService 라는 클래스를 빈으로 등록 했다면 
> 
> 스프링컨테이너는 CGLIB 이라는 바이트코드 조작 라이브러리를 사용하여 MemberService 를 상속받은 다른 클래스를 만들고
> 
> "MemberService@CGLIB..." 해당 인스턴스를 스프링 컨테이너에 등록한다.
> 
> 이 CGLIB 라이브러리가 바이트코드를 조작하여 싱글톤이 보장되게 해준다.
> 
> 예를 들어 스프링컨테이너에 등록되어있으면 그대로 반환 하고 등록되어있지 않으면 그때 Bean 메서드 호출 로직 예상.

## ComponentScan
> 스프링 빈 다 등록 해주는거 귀찮기 때문에 컴포넌트 스캔 이라는 기능을 통해 설정정보가 없어도 자동으로 스프링 빈을 등록 할 수 있다.
> 
> @Component 붙은 클래스들 모두 빈으로 등록.
> 
> 해당 ComponentScan 붙은 패키지 에서 부터 하위 패키지 까지 다 찾는다. (Default 값으로).

## @Autowired
> 스프링 컨테이너가 **해당 타입으로 빈을 조회**하여 빈 주입. (자동 주입)
>
> ComponentScan 으로 빈 등록 하게 되면 어떤 객체를 주입 해야할지 어떻게 선택 할까? 
> 바로 자동주입 @Autowired 사용.
> 
> 같은 타입이 여러개 있으면?? 뒤에서 다룰 예정.

## 수동등록 VS 자동등록
> 일반적인 Bean 등록은 자동등록을 사용하자.
> 
> 하지만 기술지원 Bean 같이 AOP 처리 등 광범위 하게 전역적으로 사용되는 빈들은 
> 수동 빈 등록을 통해 명확하게 나타내는 것이 바람직하다.

## 다양한 의존관계 주입 방법
1. 생성자 주입
- 생성자 하나일 경우 @Autowired 생략 가능.
- 생성자는 딱 1번만 호출 되기 때문에 불변성, 필수성(파라미터) 충족.

## 스프링컨테이너 라이프사이클
 1. 스프링 컨테이너에 빈 등록.
 2. 등록된 빈들 의존관계 주입.

> 생성자 주입은 컨테이너 빈 등록 하면서 의존관계 주입 된다. (결국 생성자를 호출 해야하기 때문에 빈 등록할때.)

## 수정자 주입 쓰지 않는 이유
1. 스프링 프레임워크 없이 테스트 돌릴 수가 없다. (프레임워크 의존)
> 순수 자바로 테스트 짤 수 가 없음. nullPointException
2. 테스트 용으로 인스턴스 주입하고 싶을때 넣을 방법이 없음.

## 결론
**생성자 주입방식을 사용하자.**
> 필수 값이 아닌 경우, 해당 빈이 null 값이 들어갈수도 있는 경우 수정자 주입 required 를 통해 처리.
>
> [옵션이 필요한 경우 - 수정자 주입 사용]

## 조회 대상 빈이 2개일때 - 하위타입으로 검색하는건 DIP 위반.
1. @Qualifier : 추가적인 구분자.
> 해당 이름으로 된 Qualifier 못찾으면 스프링 컨테이너에 해당 이름으로 된 빈을 찾는다. 그래도 못찾으면 예외 발생.
>
> 사용 할 거면 확실히 정의 하고 사용해야할것.

2. @Primary : 우선권을 가진다.

### 사례 : Main DB, 보조 DB 사용할 경우 Main 을 Primary 로 해놓고 보조 사용할때 Qualifier 
사용하던지 아니면 직접 주입 해주던지 등과 같이 사용.

## 조회한 빈이 모두 필요할때 - 결제 시스템 같이 동적으로 빈 적용
> Map<String, DiscountPolicy>  policyMap 이런식으로 사용.

## 빈 생명주기와 콜백
> 스프링 컨테이너 생성 -> 빈생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료.
> 
## 객체의 생성과 초기화 분리 
> 생성자에서 초기화 하는건 해당 클래스 내부의 필드들 설정 하는걸 하고 ,
> 
> 생성자 내에서 무거운 초기화 작업들은 별도의 초기화 메서드로 분리 하는게 좋다. (SRP)
> 

## 1. InitializingBean, DisposableBean : 잘 안씀. (초창기)
> afterPropertiesSet() -> 의존관계 주입 완료 후 초기화 하는 메서드.
>
> destroy() -> 컨테이너 종료 전 소멸전 콜백 메서드.

> 스프링 전용 인터페이스라 Spring 에 의존적이다.
> 
> 메서드 이름 변경 불가 

## 2. 설정 정보에 @Bean(initMethod = "init", destroyMethod="close")

## 3. @PostConstruct, @PreDestroy
> 외부라이브러리 적용 못한다. (유일한 단점) : 이럴 경우 2번째 방법 사용.
> 

정리 : 이걸 왜 배울까? :: 빈 생성 후 별도의 초기화 작업을 하기 위해서 ?? 
>데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고,
애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.

## Bean Scope
1. **SingleTon** (default) : 컨테이너 시작부터 종료까지 장수 빈
2. **Prototype** : 조회 할때마다 항상 새로운 객체 반환 해준다. 그러고 해당 빈 관리 안한다. 리턴하고 끝.
> 빈생성, 의존관계 주입, 초기화 까지만 해준다. 종료 메서드 지원 X.

> 프로토타입 빈 언제 사용 할까? 한번 생각해보자.
---

### 웹 스코프 - 웹 에서만 동작
3. **Request** : 
4. Session :
5. Application : 

## 싱글톤과 프로토타입 같이 쓸때 주의점
> 싱글톤 빈 안에 프로토타입 가지고 있을 경우 프로토타입 빈 최신화가 되지 않는다. 그냥 프로토타입 빈이 계속 생성 되지만 
> 그 빈이 싱글톤 빈 안에 있지 않아서 버그 발생.

### 해결 
1. ObjectProvider 에서 getObject.
> 스프링 컨테이너에서 getObject 할때 마다 찾아서 준다.