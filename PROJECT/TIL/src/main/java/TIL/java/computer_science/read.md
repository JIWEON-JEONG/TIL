##Process And Thread

###ContextSwitching
A ,B 프로세스 가 있을때, CPU 는 하나의 프로세스가 실행 상태가 되어있으면, 다른 프로세스는 실행상태에 올 수 없다.
그렇기 때문에 A 실행 상태에서 B가 실행되기 위해선 
A가 준비상태로 내려오고 , B가 실행상태로 가고 이러한 작업이 ContextSwitching 이다.

실행단위는 그래서 프로세스 가 될수도 있고 쓰레드가 될 수 도 있다.

프로세스 -> 메인메모리에 적재 -> CPU 에 올라간다.(실행단위)

이러한 관점에서 볼때, 스레드는 프로세스보다 효율적이다. 왜냐하면, 공용으로 사용하는 자원들이 있기때문에 Switching 될때마다 
자신이 관리 하는 데이터 Stack 영역의 데이터만 가지고 오면 된다. 그외의 힙영역이나 Data 영역, Code 영역들은 모두 공유하기 때문에 ContextSwitching 할때 영향을 받지 않음

멀티 태스킹 : 굉장히 짧은 시간으로 쪼개서 프로세스를 실행하여 마치 동시에 실행되는 것처럼 구현
단점 :
- 하나의 프로세스가 동시에 여러작업을 수행하지는 못함
- 여러 프로세스를 만들수 있지만, 프로세스의 컨텍스트 스위칭은 무거운 작업
- 프로세스 끼리 데이터 공유가 까다로움 (서로 독립적인 공간)
- 듀얼 코어가 등장했는데 잘 쓰고 싶다!! (한 CPU 안에 2개의 코어 등장) - 발열이슈로 인해 등장
- 프로세스는 한개 이상의 스레드를 가질 수 있다.
- **CPU 에서 실행되는 단위 : 쓰레드** 
- **같은 프로세스에 속한 쓰레드**들은 메모리 영역 공유!!
- 코어가 2개면 진정한 동시 실행이 되고, 아니면 멀티태스킹 방식으로 사용된다. 
- 두개 이상의 프로세서나, 코어를 활용하는 시스템을 멀티 프로세싱 이라고 하고, 하나의 프로세스가 동시에 여러 작업을 실행하는건 멀티스레딩이라고 한다.

인텔리제이에서 내가 코드를 치면서 추천코드를 보여주는 것이 멀티쓰레드 의 예시이다.
또는 테스트를 돌리는 동시에 코드를 수정하는 등.


멀티 쓰레드 , 멀티 프로세스 -> 처리방식의 일종이다. (한 어플리케이션의 두가지 처리방식)

멀티쓰레드의 단점
- 긴밀하게 연결되어있기 때문에 한 쓰레드에 문제가 생기면 다른 쓰레드에도 영향이 간다.
- 참고로 구글 에서는 그래서 멀티프로세서 이용.
- 


Process

- 각각의 프로세스는 독립된 메모리 공간을 할당받는다.(명령어들과 데이터를 갖는다 - 메모리 영역 사진 참고)
- 
___
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.
  Ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용
- 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.

Thread
- 프로세스 내에서 실행되는 여러 흐름의 단위 , 즉 프로세스의 특정한 수행 경로.
- 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 

![](../../../../../스크린샷 2022-07-19 오후 10.36.02.png)

멀티프로세스

<사전지식>
CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 데 이 과정을 Context Switching라 한다.
구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.

멀티 프로세싱이란
 - 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것이다.
 - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다
 - Context Switching에서의 오버헤드
   Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.
   프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
 - 프로세스 사이의 어렵고 복잡한 통신 기법(IPC)
    프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

멀티쓰레드란 

- 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다.
  윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.
  웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.
- 시스템 자원 소모 감소 (자원의 효율성 증대)
  프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
- 시스템 처리량 증가 (처리 비용 감소)
  스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
  스레드 사이의 작업량이 작아 Context Switching이 빠르다
- 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
  스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
###주의할점 

- 주의 깊은 설계가 필요하다.
- 디버깅이 까다롭다.
- 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
- 다른 프로세스에서 스레드를 제어할 수 없다. (즉, 프로세스 밖에서 스레드 각각을 제어할 수 없다.)
- 멀티 스레드의 경우 자원 공유의 문제가 발생한다. (동기화 문제)
추가 설명 : 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다.
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

### 멀티프로세스 vs 멀티스레드

:: 프로그램을 여러개 키냐 , 하나의 프로그램 안에서 여러 작업을 하냐 의 문제 라고 볼수 있다.

멀티쓰레드를 이용하면 
1. 자원의 효율성을 증대 시킬 수 있다. 프로세스 간의 ContextSwitching 시 오버헤드가 크다.
2. 처리 비용 감소 및 응답 시간 단축 - contextSwitching 시 Stack 영역만 처리.


##CPU Scheduling

스케줄링은 여러 프로세스가 번갈아가며 사용하는 자원을 어떤 시점에 어떤 프로세스에게 자원을 할당할 지 결정하는 것이다.
스케줄링 방법에 따라 프로세서(CPU)를 할당받을 프로세스를 결저하므로 스케줄링은 시스템의 성능에 직/간접적인 영향을 미친다.
좋은 스케줄링은 프로세서의 효율성을 높이고, 프로세스의 응답시간을 최소화하여 시스템의 작업 처리 능력을 향상시킨다.즉, cpu가 쉬지않고 계속해서 돌 수 있도록 해준다.

CPU를 Running 시킬때 보다 I/O 를 Waiting 하는 시간이 더 크다. 
ready 상태에 있는 프로세스 중에서 실행상태로 할당 시켜주는 것 -> 스케줄링

readyQueue 를 구현해야하는데, -> 우선순위 큐로 구현을 한다. 
당장 필요한 작업이 있을수 있으니까.
우선순위를 정해야한다. 그래서.. 

##선점 과 비선점
선점 : 프로세스를 쫓아낼수 있다. 
비선점 : 프로세스가 자발적으로 나와야 한다. 쫓아낼수 없음.

스케줄러와 디스패쳐
스케줄러가 선택해주고 실제로 ContextSwitch 해주는건 디스패처가 해준다.

스케줄링 목표
1. CPU 를 바쁘게 만들자 
2. 시간당 처리량 (프로세스 완료)를 많이 높이자.
3. 실행에서 종료까지의 시간을 줄이자
**4. ready queue 에서 대기하는 시간을 최소화 하자**

선점 스케줄링(preemptive)은 시분할 시스템에서 타임 슬라이스가 소진되었거나, 
인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때,
현 실행 프로세스로부터 강제로 CPU를 회수하는 것을 말한다. 

데이터가 다수의 프로세스에 의해 공유될 때 racing condition이 발생될 수 있다.
mutex lock, monitor 등의 기법을 사용해서 racing condition을 피한다.

**race condition (경쟁 상태)
경쟁 상태(race condition)란 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다.
입력 변화의 타이밍이나 순서가 예상과 다르게 작동하면 정상적인 결과가 나오지 않게 될 위험이 있는데 이를 경쟁 위험이라고 한다.
인터럽트는 어느 시점에서건 일어날 수 있고, 커널에 의해서 항상 무시될 수는 없기 때문에, 인터럽트에 의해서 영향을 받는 코드 부분은 반드시 동시 사용으로부터 보호되어야 한다.**


##Synchronize And Deadlock

멀티쓰레드 환경에서 , 동시성 제어를 하기 위한 방법으로 동기화를 이용하는데, 이때 Deadlock 이 발생할수 있으니 조심하자.
결국 동기화를 하게 되는 순간은 그 자원에 대해 락이 걸린다는 것이기 때문에 충분히 교착상태에 빠질수 있다.

**해결하기 위한 방법으로는 중첩 Synchronize 를 사용하지 않아야한다.** 이 방법이 생각보다 잘 보이지 않고 (메서드를 타고 타고 가야 보이는 것은 눈에 띄지 않음)
구현하기 힘들수 있다.




###Deadlock
- 두개 이상의 작업이 서로 상대방(프로세스)의 작업(리소스)이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태 (점유, 대기)
- 상호배제 (하나의 공유자원에 대해 둘이상의 프로세스가 접근할 수 없다.)
- 점유 대기 (하나의 자원을 점유하는 프로세스가 있으면 요청을 하고 대기를 해야한다.)
- 비선점, 순환대기

- 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황이 발생 할 수 있습니다.
- 어떤 프로세스가 자원을 요청 했을 때 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있고 그 때는 프로세스가 대기 상태로 들어 가게됩니다.

#결과적으로 3가지 개념을 합쳐서 이해해야 할거같다. 연결지어서 설명해보자. - 스터디 때 토의.

<process , thread , scheduling , deadlock, synchronized>


